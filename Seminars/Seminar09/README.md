# Move семантики

## Типове изрази
- всеки израз си има тип (напр. int) и категория на стойността
- категорията на стойността показва дали изразът се оценява до стойност, функция или някакъв обект

### lvalue
- израз, който се оценява като идентифицируем обект или функция (т.е. има адрес в паметта, може да се достъпни чрез идентификатор, референция или указател и има живот, по-дълъг от този на обикновен израз или оператор)
- променливи, функции, връщащи референция към някакъв тип, стринг литерали и т.н.

```c++
int x;

int& getRef() {
	return x;
}

int main() {
    int x = 7;
	getRef() = 4;
	return 0;
}
```

### rvalue
- всичко, което не е lvalue (т.е. prvalue или xvalue)
- израз, който се оценява до стойност
- не могат да бъдат идентифицирани (което означава, че трябва да бъдат използвани веднага) и съществуват само в обхвата на израза, в който са използвани

## prvalue ("pure" rvalue)
- изчислява стойността на операнд на вграден оператор
- инициализира обект
- литерали (без стринг литералите), функции, връщащи стойност и т.н.

## xvalue ("eXpiring" value)
- обект, който е към края на жизнения си цикъл (обект, чиито ресурси могат да се използват повторно)

```c++
4 = var;        //Error
(var + 1) = 4;  //Error
```

```c++
int x;

int getRef() {
	return x;
}

int main() {
	getRef() = 4;  //Error
}
```

## Rvalue reference (C++ 11)
- референция, която е предназначена да бъде инициализирана с rvalue
- сочи само към временни обекти
- синтаксис: двоен амперсанд `&&`

```c++
int i = 42;
int &r = i; // ok: r refers to i
int &&rr = i; // error: cannot bind an rvalue reference to an lvalue

int &r2 = i * 42; // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42; // ok: bind rr2 to the result of the multiplication
```

- ако искаме да пренасочим rvalue reference към lvalue, можем да преобразуваме lvalue към xvalue, използвайки функцията `std::move()`
- това е временно преобразуване - обекта си остава lvalue и животът му не се прекратява

```c++
int x = 5;
int&& xRRef = x;   //Error: rvalue reference cannot be bound to an lvalue

int&& xRRef = std::move(x);  //Ok
```

### Предимства
- rvalue референциите удължават живота на обекта
- неконстантните rvalue референции позволяват да променяме стойността
- можем да предефинираме фунцкионалности, в които спестяваме излишни копия, ако обектите са временни
- компилаторът сам преценява коя функция да извика - в зависимост от това дали му се подаде lvalue или rvalue

```c++
void print(const MyString& str) {
        std::cout << str;
}
 
void print(MyString&& str) {
        std::cout << str;
}

MyString name = "Pesho";

print(name);  //lvalue
print("Ivan");   //rvalue
```
## Move конструктор и move оператор=
- целта е да се прехвърли собствеността на ресурсите от един обект на друг
- вместо дълбоко копиране на изходния обект, просто преместваме (крадем) ресурсите му
- ако има указател в обекта, който копираме, се получава shallow copy на указателя на източника, затова се налага указателят на източника се зададе на nullptr
```c++
Person::Person(Person&& other) noexcept {
	moveFrom(std::move(other));
}
```

```c++
Person& Person::operator=(Person&& other) noexcept {
	if(this != &other) {
		free();	
        moveFrom(std::move(other));
	}

	return *this;
}
```

```c++
void Person::moveFrom(Person&& other) {
    this.name = other.name;
    other.name = nullptr;

    this.age = other.age;
}
```

- извикват се, когато тези функции са дефинирани и аргументът за конструиране или присвояване е rvalue
- най-често тази стойност е литерална или временна стойност
- ако се подава на функция, която приема rvalue референция, move конструктор и move оператор= НЕ СЕ ВИКАТ

## Генериране на move конструктор и move оператор=

компилаторът ще създаде подразбиращ се move конструктор и move оператор=, ако всички от следните условия са верни:

- няма деклариран от потребителя copy конструктор или copy оператор=
- няма деклариран от потребителя move конструктор или move оператор=
- няма деклариран от потребителя деструктор

Имплицитният move конструктор и move оператор=move извършват преместване по посока на членовете. Това означава, че всеки член на преместения от обект се премества в преместения към обект.