# Оператори

- в C++ операторите са реализирани като функции

## Видове оператори
1. Унарни - само на един елемент
    - `++`, `!`, `~`
2. Бинарни - 2 елемента: ляв и десен
    - `+`, `-`, `*`, `/`
3. Тернарни
    - `? :` 
- някои оператори могат да бъдат и унарни, и бинарни:
    - `+a`, `-a`
## Характеристики 
 ### Приоритет 
 - aко в един израз има няколко оператора, приоритетът определя коя операция ще се изпълни първа
 ```cpp
 5 + 3 * 2 -> 5 + (3 * 2)
 ```
 ### Асоциативност 
 - определя посоката, в която се оценява израза
 - ляво асоциативни `(((a $ b) & c) $ d)`
    - `+`, `-`, `*`. `/`
 - дясно асоциативни `(a & (b & (c & d)))`
    - `+=`, `-=`, `*=`. `/=`

 ### Позиция на оператора спярмо аргумента 
 - префиксни
    - `++a`, `!a`, `~a`, `*a` (дереферира)
 - инфиксни
    - `a + b`
 - суфиксни
    - `a++`

 [Повече информация за операторите](https://en.cppreference.com/w/cpp/language/operator_precedence)

## Предефиниране
- предефинирането на функциите на операторите ни позволява да имаме свои собствени версии на операторите
- синтаксис: ключовата дума `operator`, последвана от символа на съответния оператор
- могат да се предефинират като външни функции и като член-функции
- ако е операторът е предефиниран като член-функция, обектът от класа, в който дефиниран операторът, се явява най-ляв аргумент (т.е. отляво на оператора, ако е бинарен)

## Ограничения
- почти всеки съществуващ оператор в C++ може да бъде предефиниран
- изключенията са: 
    - conditional `?:`
    - `sizeof`
    - scope `::`
    - member selector `.`
    - pointer member selector `.*`
    - `typeid` и casting

- можем да предефинираме само съществуващите оператори - не можем да създаваме нови оператори или да преименуваме съществуващи оператори (напр. не можем да създадем operator**, който да работи с експоненти)
- поне един от параметрите в предефинирания оператор трябва да бъде дефиниран от нас тип (можем да предефинираме operator+(int, Mystring), но не и operator+(int, double))
- всички оператори запазват своята **приоритетност** и **асоциативност**, броя и позицията на **аргументите** си

## Алгебрични оператори
- могат да се предефинират и като външни функции, и като член-функции
```cpp
class Test {
private:
    int num1;
    int num2;
};
```
- `+=` трябва да връща променлива, т.е. lvalue

```cpp
Test& Test::operator+=(const Test& other) {
    num1 += other.num1;
    num2 += other.num2;
    return *this;
}
```
```cpp
Test& operator+=(Test& lhs, const Test& rhs) {
    lhs.num1 += rhs.num1;
    lhs.num2 += rhs.num2;
    return lhs;
}
```
- `+` трябва да връща стойност (не променлива), т.е. rvalue
```cpp
Test Test::operator+(const Test& other) const {
    int new_num1 = num1 + other.num1;
    int new_num2 = num2 + other.num2;
    return Test{new_num1, new_num2};
}
```
```cpp
Test operator+(const Test& lhs, const Test& rhs) {
    int new_num1 = lhs.num1 + rhs.num1;
    int new_num2 = lhs.num2 + rhs.num2;
    return Test{new_num1, new_num2};
}
```
- можем да преизползваме `+=`
```cpp
Test operator+(const Test& lhs, const Test& rhs) {
    Test res(lhs);
    res += rhs;
    return res;
}
```
- имаме алтернативен запис:
```cpp
int main() {
    Test t1;
    Test t2;
    Test t3 = t1.operator+(t2); // за член-функции
    Test t4 = operator+(t1, t2); // за външни функции
}
```
**Уговорка !!!**
- `+=`, `-=`, `*=`. `/=` - член-функции (променят обекта, върху който са извикани)
- `+`, `-`, `*`. `/` - външни функции (двата обекта са "равностойни")

## Оператори за инкрементации и декрементации
- **префиксните** връщат променлива, т.е. lvalue
```cpp
Test& Test::operator++() {
    num1++;
    num2++;
    return *this;
}
```
- **суфикснинте** връщат старата стойност, т.е. rvalue
- добавя се dummy параметър, който в общия случай не се ползва, но указва, че предефинираме суфиксния оператор
```cpp
Test Test::operator++(int n) {
    num1++;
    num2++;
    return Test{num1 - 1, num2 - 1};
}
```

## Оператори за потоци
- функциите трябва да са външни, защото, ако бяха вътрешни, левият параметър щеше да е обектът
- правилно е левият параметър да е потокът, а десният - обектът 

```cpp
std::istream& operator>>(std::istream& in, Test& obj) {
    in >> obj.num1 >> obj.num2;
    return in;
}

std::ostream& operator<<(std::ostream& out, const Test& obj) {
    out << obj.num1 << ", " << obj.num2;
    return out;
}
```

## Добри практики
- когато предефинираме оператори, най-добре е да ги запазим най-близо до първоначалния им замисъл
- ако значението на предефинирания оператор не е ясно и интуитивно, използваме обикновена функция
- операторите, които не променят своите операнди, трябва да връщат резултати по стойност (и са външни за класа, при необходимост приятелски) 
- операторите, които променят най-левия си операнд, трябва да връщат най-левия операнд по референция (и са член-функции)
- aко се извършва IO върху класа, то се дефинират shift операторите `<<` и `>>`;
- aко класът изисква проверка за равенство, то се дефинира оператора `==` (обикновено и оператора `!=`)
- aко класът притежава някакъв вид наредба, то се дефинира оператора `<` (обикновено останалите релационни оператори)
- return type-a на един предефиниран оператор трябва да бъде съвместим с return-a на вградените (built in) оператори

# Приятелски функции/класове
- Приятелска функция - **външна** функция за клас, която има достъп до private и protected член-данните и член-функциите на класа
- Приятелски клас - **външен** клас, който има достъп до private и protected член-данните и член-функциите на текущия клас

Приятелски класове/функции:
- Не се наследяват
- Не са транзитивни (приятелски клас на ваш приятелски клас не е приятелски клас на вас)
- Може да се напишат в private, protected, public частта на class-a (добрата практика е само в public)

```cpp
class Test {
private:
    int num1;
    int num2;

public:
    friend std::istream& operator>>(std::istream& in, Test& obj);

    friend std::ostream& operator<<(std::ostream& out, const Test& obj);
};
```